<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>App Emozionale</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .container {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
        }
        .card {
            background-color: white;
            padding: 2rem;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            width: 100%;
            max-width: 500px;
            text-align: center;
            position: relative;
        }
        .btn-primary {
            background-color: #6366f1; /* Indigo */
            color: white;
            padding: 0.75rem 2rem;
            border-radius: 9999px;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .btn-primary:hover {
            background-color: #4f46e5;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px -2px rgba(0, 0, 0, 0.1);
        }
        .btn-secondary {
            background-color: #e5e7eb;
            color: #4b5563;
            padding: 0.75rem 2rem;
            border-radius: 9999px;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .btn-secondary:hover {
            background-color: #d1d5db;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            width: 3rem;
            height: 3rem;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .plan-item {
            background-color: #ffffff;
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            text-align: left;
        }
        .link-text {
            color: #6366f1;
            text-decoration: underline;
        }
        .message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 1000;
            transition: opacity 0.5s ease-in-out;
            opacity: 0;
            pointer-events: none;
        }
        .message-box.show {
            opacity: 1;
        }
        .image-container {
            width: 100%;
            height: 250px;
            overflow: hidden;
            border-radius: 1.5rem;
            margin-bottom: 1.5rem;
            background-color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.5s ease-in-out;
        }
    </style>
</head>
<body>

<div class="container" id="app-container">
    <!-- Le sezioni verranno renderizzate dinamicamente qui -->
</div>

<!-- Casella per i messaggi -->
<div id="message-box" class="message-box"></div>

<script type="module">
    // Gestione delle dipendenze per l'esecuzione locale
    let firebaseApp, auth, db;
    let currentUserId = "offline-user"; // ID utente fittizio per la modalità offline
    let isOffline = true;

    // Rende le funzioni globali in modo che gli attributi 'onclick' nell'HTML possano accedervi.
    window.navigateTo = navigateTo;
    window.answerQuestion = answerQuestion;
    window.saveDailyPlan = saveDailyPlan;
    window.playMusic = playMusic;

    let firebaseAppModule, authModule, firestoreModule;

    // Carica le dipendenze Firebase solo se disponibili
    if (typeof __firebase_config !== 'undefined') {
        isOffline = false;
        firebaseAppModule = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js");
        authModule = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js");
        firestoreModule = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js");
        firestoreModule.setLogLevel('debug');
    }

    async function initApp() {
        if (!isOffline) {
            const { initializeApp } = firebaseAppModule;
            const { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } = authModule;
            const { getFirestore } = firestoreModule;
            
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const firebaseConfig = JSON.parse(__firebase_config);
            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
            
            firebaseApp = initializeApp(firebaseConfig);
            auth = getAuth(firebaseApp);
            db = getFirestore(firebaseApp);
            
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUserId = user.uid;
                    console.log("Utente autenticato:", currentUserId);
                } else {
                    console.log("Utente non autenticato. Accesso anonimo.");
                    if (initialAuthToken) {
                        try {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } catch (error) {
                            console.error("Errore di autenticazione con token personalizzato:", error);
                            await signInAnonymously(auth);
                        }
                    } else {
                        await signInAnonymously(auth);
                    }
                }
                navigateTo('start');
            });
        } else {
            navigateTo('start');
        }
    }

    const appContainer = document.getElementById('app-container');
    const apiKey = "";
    const textApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
    const imageApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;

    let currentPlan = null;
    let currentMusicPlayer = null;
    let currentTonePart = null;

    // Dati musicali più complessi che non sono solo accordi singoli
    const musicStyles = {
        'Clair de Lune': {
            synth: new Tone.PolySynth(Tone.FMSynth, {
                envelope: {
                    attack: 0.5,
                    decay: 1.5,
                    sustain: 0.5,
                    release: 3
                },
                harmonicity: 3.01,
                modulationIndex: 14,
                detune: 0,
                oscillator: { type: "sine" },
                modulation: { type: "sawtooth" },
                volume: -15
            }).toDestination(),
            part: [
                ["0", ["C4", "Eb4", "G4"]],
                ["2n", ["D4", "F4", "A4"]],
                ["1n", ["C4", "Eb4", "G4"]],
                ["2n", ["G3", "Bb3", "D4"]]
            ]
        },
        'Gymnopédie No. 1': {
            synth: new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "triangle" },
                envelope: { attack: 0.1, decay: 0.5, sustain: 0.5, release: 1 },
                volume: -12
            }).toDestination(),
            part: [
                ["0", ["G4", "D5", "G5"]],
                ["1n", ["F4", "C5", "F5"]],
                ["2n", ["E4", "B4", "E5"]],
                ["4n", ["D4", "A4", "D5"]]
            ]
        },
        'Le Carnaval des Animaux: Le Cygne': {
            synth: new Tone.PolySynth(Tone.FMSynth, {
                envelope: {
                    attack: 0.5,
                    decay: 0.5,
                    sustain: 1,
                    release: 2
                },
                harmonicity: 3.01,
                modulationIndex: 14,
                detune: 0,
                oscillator: { type: "sine" },
                modulation: { type: "sawtooth" },
                volume: -15
            }).toDestination(),
            part: [
                ["0", ["A3", "C4", "E4"]],
                ["2n", ["A3", "C4", "E4"]],
                ["1n", ["G3", "B3", "D4"]],
                ["2n", ["F3", "A3", "C4"]]
            ]
        },
        'Nocturne in E-flat major, Op. 9, No. 2': {
            synth: new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "triangle" },
                envelope: { attack: 0.5, decay: 0.5, sustain: 0.5, release: 1 },
                volume: -12
            }).toDestination(),
            part: [
                ["0", ["Eb4", "G4", "Bb4"]],
                ["2n", ["F4", "Ab4", "C5"]],
                ["1n", ["Eb4", "G4", "Bb4"]],
                ["2n", ["C4", "Eb4", "G4"]]
            ]
        }
    };
    
    // Aggiungi un effetto di riverbero
    const reverb = new Tone.Reverb(2).toDestination();
    for (const style in musicStyles) {
        musicStyles[style].synth.connect(reverb);
    }

    const questions = [
        {
            text: "Come ti senti al risveglio?",
            answers: [
                { text: "Pieno di energia", value: "energia" },
                { text: "Un po' assonnato", value: "assonnato" },
                { text: "Mi sento calmo", value: "calmo" },
                { text: "Non sono sicuro", value: "incerto" }
            ]
        },
        {
            text: "Quando sei stressato, cosa ti aiuta di più?",
            answers: [
                { text: "Stare da solo", value: "solitudine" },
                { text: "Parlare con qualcuno", value: "comunicazione" },
                { text: "Ascoltare musica", value: "musica" },
                { text: "Passare del tempo nella natura", value: "natura" }
            ]
        },
        {
            text: "Quale frase ti ispira di più?",
            answers: [
                { text: "La vera felicità è nella condivisione.", value: "sociale" },
                { text: "La tua forza interiore è la tua bussola.", value: "forza_interiore" },
                { text: "Ogni giorno è una nuova opportunità.", value: "opportunita" }
            ]
        }
    ];

    let userAnswers = {};
    let currentQuestionIndex = 0;

    /**
     * Naviga tra le diverse viste dell'app.
     * @param {string} viewName - Il nome della vista ('start', 'questionnaire', 'loading', 'dailyPlan', 'history', 'error').
     * @param {object} [data] - Dati opzionali da passare alla vista.
     */
    function navigateTo(viewName, data = {}) {
        appContainer.innerHTML = '';
        // Controlla se c'è una parte musicale in esecuzione e la ferma
        if (currentMusicPlayer) {
            currentMusicPlayer.stop();
            currentMusicPlayer = null;
        }

        switch (viewName) {
            case 'start':
                renderStartView();
                break;
            case 'questionnaire':
                renderQuestionnaire();
                break;
            case 'loading':
                renderLoadingView();
                generateDailyPlan();
                break;
            case 'dailyPlan':
                currentPlan = data;
                renderDailyPlanView(data);
                break;
            case 'history':
                renderHistoryView();
                break;
            case 'error':
                renderErrorView(data);
                break;
        }
    }

    function renderStartView() {
        userAnswers = {};
        currentQuestionIndex = 0;
        appContainer.innerHTML = `
            <div class="card">
                <h1 class="text-3xl sm:text-4xl font-bold mb-4 text-gray-800">Benvenuto!</h1>
                <p class="text-lg text-gray-600 mb-6">Inizia il nostro questionario per ricevere un messaggio emozionale personalizzato.</p>
                <div class="flex flex-col sm:flex-row justify-center gap-4">
                    <button onclick="navigateTo('questionnaire')" class="btn-primary">Inizia Questionario</button>
                    ${isOffline ? `<button class="btn-secondary" disabled>Vedi Storico</button>` : `<button onclick="navigateTo('history')" class="btn-secondary">Vedi Storico</button>`}
                </div>
                ${isOffline ? `<p class="text-sm text-gray-400 mt-6">Modalità offline. Le funzionalità di salvataggio e storico sono disabilitate.</p>` : `<p class="text-sm text-gray-400 mt-6">Il tuo ID utente per la sincronizzazione: ${currentUserId}</p>`}
            </div>
        `;
    }

    function renderQuestionnaire() {
        const currentQuestion = questions[currentQuestionIndex];
        const answersHtml = currentQuestion.answers.map(answer => `
            <button onclick="answerQuestion('${answer.value}')" class="btn-secondary mb-2 w-full text-center">${answer.text}</button>
        `).join('');

        appContainer.innerHTML = `
            <div class="card">
                <h2 class="text-2xl font-semibold mb-4 text-gray-800">${currentQuestion.text}</h2>
                <div class="flex flex-col gap-4">
                    ${answersHtml}
                </div>
            </div>
        `;
    }

    function answerQuestion(answerValue) {
        userAnswers[`q${currentQuestionIndex + 1}`] = answerValue;
        currentQuestionIndex++;
        if (currentQuestionIndex < questions.length) {
            navigateTo('questionnaire');
        } else {
            navigateTo('loading');
        }
    }

    function renderLoadingView() {
        appContainer.innerHTML = `
            <div class="card bg-indigo-600 text-white flex flex-col items-center">
                <div class="loading-spinner mb-4"></div>
                <h2 class="text-2xl font-semibold text-white">Stiamo preparando il tuo piano...</h2>
                <p class="mt-2 text-indigo-200 text-center">Attendere prego, l'AI sta elaborando i tuoi dati e generando contenuti multimediali.</p>
            </div>
        `;
    }

    function renderDailyPlanView(plan) {
        const planItemsHtml = Object.keys(plan.schedule).map(time => {
            const timeSlot = plan.schedule[time];
            const imageUrl = timeSlot.image_data ? `data:image/png;base64,${timeSlot.image_data}` : 'https://placehold.co/400x250/e2e8f0/4b5563?text=Errore+Immagine';
            const imageAlt = timeSlot.image_data ? timeSlot.image_description : 'Immagine non disponibile';
            
            return `
                <div class="plan-item">
                    <h3 class="text-xl font-bold text-gray-800 mb-2">${time}</h3>
                    <p class="text-gray-600 mb-2">${timeSlot.message}</p>
                    
                    <p class="text-sm text-gray-500 mt-4 mb-2">Immagine generata:</p>
                    <img src="${imageUrl}" class="rounded-lg mt-2 mb-2 w-full max-h-64 object-cover" alt="${imageAlt}">
                    
                    <p class="text-sm text-gray-500 mt-4 mb-2">Brano suggerito:</p>
                    <p class="text-sm font-semibold text-gray-700">${timeSlot.music_title}</p>
                    <p class="text-xs text-gray-500">Compositore: ${timeSlot.music_composer}</p>
                    ${musicStyles[timeSlot.music_title] ? 
                        `<button onclick="playMusic('${timeSlot.music_title}')" class="btn-secondary mt-2">Ascolta un estratto</button>` : 
                        `<p class="text-sm text-gray-400 mt-2">Nessun estratto disponibile per questo brano.</p>`
                    }
                </div>
            `;
        }).join('');

        appContainer.innerHTML = `
            <div class="card text-left">
                <h2 class="text-2xl font-bold text-gray-800">Ciao, ${plan.profile}!</h2>
                <p class="text-lg text-gray-600 mb-6">Ecco il tuo piano di benessere per la giornata.</p>
                ${planItemsHtml}
                <div class="flex flex-col sm:flex-row justify-center gap-4 mt-6">
                    ${isOffline ? `<button class="btn-primary" disabled>Salva il Piano (solo online)</button>` : `<button onclick="saveDailyPlan()" class="btn-primary">Salva il Piano e Abilita Notifiche</button>`}
                    <button onclick="navigateTo('start')" class="btn-secondary">Inizia un nuovo piano</button>
                </div>
            </div>
        `;
    }

    /**
     * Riproduce una melodia generata proceduralmente per una durata di almeno 15 secondi.
     * @param {string} styleName - Lo stile musicale da riprodurre.
     */
    async function playMusic(styleName) {
        // Avvia il contesto audio solo se non è già attivo.
        if (Tone.context.state !== 'running') {
            await Tone.start();
        }

        // Se la musica è già in riproduzione e il brano è lo stesso, interrompi.
        if (currentMusicPlayer && currentMusicPlayer.styleName === styleName) {
            currentMusicPlayer.stop();
            currentMusicPlayer = null;
            showMessage(`Riproduzione di "${styleName}" interrotta.`);
            return;
        }

        // Interrompi qualsiasi brano precedente prima di avviarne uno nuovo.
        if (currentMusicPlayer) {
            currentMusicPlayer.stop();
        }
        
        try {
            const style = musicStyles[styleName];
            if (!style) {
                const errorMessage = `Stile musicale "${styleName}" non trovato.`;
                console.warn(errorMessage);
                showMessage(errorMessage);
                return;
            }

            const synth = style.synth;
            const partData = style.part;

            // Crea una nuova parte con la sequenza di accordi
            currentTonePart = new Tone.Part((time, chord) => {
                synth.triggerAttackRelease(chord, "8n", time);
            }, partData).start(0);

            // Imposta un loop per 8 volte per una durata di circa 20-30 secondi
            currentTonePart.loop = true;
            currentTonePart.loopEnd = partData[partData.length - 1][0] + "n";
            currentTonePart.playbackRate = 1;
            
            // Imposta il trasporto e avvia la riproduzione
            Tone.Transport.start();
            
            currentMusicPlayer = {
                styleName: styleName,
                stop: () => {
                    currentTonePart.stop();
                    currentTonePart.dispose();
                    Tone.Transport.stop();
                    Tone.Transport.cancel();
                    currentTonePart = null;
                }
            };
            
            showMessage(`Riproduzione di un estratto di "${styleName}"`);
        } catch (error) {
            console.error("Errore durante la riproduzione:", error);
            showMessage("Errore durante la riproduzione. Riprova più tardi.");
        }
    }

    async function renderHistoryView() {
        appContainer.innerHTML = `
            <div class="card">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">Storico Piani Salvati</h2>
                <div id="history-list" class="flex flex-col gap-4">
                    <p class="text-gray-500">Caricamento dello storico...</p>
                </div>
                <button onclick="navigateTo('start')" class="btn-secondary mt-6">Torna alla Home</button>
            </div>
        `;

        if (isOffline) {
            document.getElementById('history-list').innerHTML = '<p class="text-gray-500">Lo storico non è disponibile in modalità offline.</p>';
            return;
        }

        // Accedi alle funzioni del database direttamente qui
        const { collection, getDocs } = firestoreModule;
        const historyList = document.getElementById('history-list');
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const userHistoryCollection = collection(db, `artifacts/${appId}/users/${currentUserId}/daily_plans`);
        
        try {
            const snapshot = await getDocs(userHistoryCollection);
            if (snapshot.empty) {
                historyList.innerHTML = '<p class="text-gray-500">Nessun piano salvato. Salva il tuo primo piano!</p>';
                return;
            }

            const plans = [];
            snapshot.forEach((doc) => {
                plans.push({ id: doc.id, data: doc.data() });
            });

            plans.sort((a, b) => new Date(b.id) - new Date(a.id));

            historyList.innerHTML = '';
            plans.forEach((planDoc) => {
                const plan = planDoc.data;
                const timestamp = new Date(planDoc.id).toLocaleString('it-IT');
                const planHtml = `
                    <div class="plan-item">
                        <p class="text-sm text-gray-500 mb-2">${timestamp}</p>
                        <h3 class="text-xl font-bold text-gray-800 mb-2">Profilo: ${plan.profile}</h3>
                        <p class="text-gray-600 text-sm italic">Messaggio del mattino: "${plan.schedule['Mattino (8:00)'].message.substring(0, 50)}..."</p>
                    </div>
                `;
                historyList.innerHTML += planHtml;
            });

        } catch (error) {
            console.error("Errore nel caricamento dello storico:", error);
            historyList.innerHTML = '<p class="text-gray-500">Errore nel caricamento dello storico. Riprova.</p>';
        }
    }

    function renderErrorView(data) {
        appContainer.innerHTML = `
            <div class="card">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">Ops! Qualcosa è andato storto.</h2>
                <p class="text-lg text-gray-600 mb-6">${data.message}</p>
                <button onclick="navigateTo('start')" class="btn-primary">Riprova</button>
            </div>
        `;
    }

    /**
     * Salva il piano giornaliero nel database Firestore e abilita le notifiche.
     */
    async function saveDailyPlan() {
        if (isOffline) {
            showMessage("Questa funzione è disponibile solo in modalità online.");
            return;
        }

        if (!currentPlan) return;
        
        const planToSave = {
            profile: currentPlan.profile,
            schedule: {}
        };

        Object.keys(currentPlan.schedule).forEach(timeKey => {
            const timeSlot = currentPlan.schedule[timeKey];
            planToSave.schedule[timeKey] = {
                message: timeSlot.message,
                image_description: timeSlot.image_description,
                music_title: timeSlot.music_title,
                music_composer: timeSlot.music_composer
            };
        });

        const { doc, setDoc } = firestoreModule;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const docId = new Date().toISOString();
        const planDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/daily_plans`, docId);
        try {
            await setDoc(planDocRef, planToSave);
            console.log("Piano salvato con successo!");
            scheduleNotifications(currentPlan);
            navigateTo('start');
        } catch (e) {
            console.error("Errore nel salvataggio del piano:", e);
            navigateTo('error', { message: 'Impossibile salvare il piano. Riprova più tardi.' });
        }
    }

    /**
     * Richiede il permesso per le notifiche e le programma.
     */
    function scheduleNotifications(plan) {
        if (isOffline || !('Notification' in window)) {
            console.warn("Le notifiche non sono supportate in questo ambiente.");
            return;
        }

        Notification.requestPermission().then(permission => {
            if (permission === 'granted') {
                const now = new Date();
                const times = {
                    'Mattino (8:00)': 8,
                    'Metà giornata (11:00)': 11,
                    'Pomeriggio (14:00)': 14,
                    'Sera (18:00)': 18
                };

                Object.keys(plan.schedule).forEach(timeKey => {
                    const hour = times[timeKey];
                    const targetTime = new Date();
                    targetTime.setHours(hour, 0, 0, 0);

                    // Se l'ora di destinazione è già passata, programma per domani
                    if (targetTime < now) {
                        targetTime.setDate(targetTime.getDate() + 1);
                    }

                    const delay = targetTime.getTime() - now.getTime();
                    
                    if (delay > 0) {
                        setTimeout(() => {
                            new Notification('Il tuo momento di benessere!', {
                                body: plan.schedule[timeKey].message,
                                icon: 'https://placehold.co/64x64/6366f1/ffffff?text=App'
                            });
                        }, delay);
                    }
                });
            } else {
                console.log("Permesso di notifica negato dall'utente.");
            }
        });
    }

    /**
     * Mostra un messaggio a comparsa per un breve periodo di tempo.
     * @param {string} message - Il messaggio da visualizzare.
     */
    function showMessage(message) {
        const messageBox = document.getElementById('message-box');
        messageBox.textContent = message;
        messageBox.classList.add('show');
        setTimeout(() => {
            messageBox.classList.remove('show');
        }, 3000);
    }

    /**
     * Genera un piano giornaliero personalizzato usando il modello Gemini.
     */
    async function generateDailyPlan() {
        if (isOffline) {
            // Genera un piano fittizio per la modalità offline
            const mockPlan = {
                profile: "L'Anima Calma",
                schedule: {
                    "Mattino (8:00)": {
                        message: "Inizia la giornata con un respiro profondo e la consapevolezza del momento presente. Trova il tuo centro prima di affrontare la frenesia quotidiana.",
                        image_description: "Un lago calmo all'alba, circondato da montagne. I colori tenui del cielo si riflettono sull'acqua immobile.",
                        music_title: "Gymnopédie No. 1",
                        music_composer: "Erik Satie",
                        image_data: null
                    },
                    "Metà giornata (11:00)": {
                        message: "Fai una pausa di 5 minuti, concentrati sul tuo respiro e lascia andare le tensioni. Riconnettiti con la tua forza interiore.",
                        image_description: "Una singola candela accesa in una stanza buia, con un'atmosfera serena e pacifica.",
                        music_title: "Nocturne in E-flat major, Op. 9, No. 2",
                        music_composer: "Frédéric Chopin",
                        image_data: null
                    },
                    "Pomeriggio (14:00)": {
                        message: "Rilassati e stacca dalla routine. Fai una breve passeggiata o ascolta della musica per resettare la mente.",
                        image_description: "Un sentiero forestale illuminato dal sole, con un'atmosfera di calma e pace.",
                        music_title: "Clair de Lune",
                        music_composer: "Claude Debussy",
                        image_data: null
                    },
                    "Sera (18:00)": {
                        message: "Rifletti sulle emozioni della giornata. Scrivi un pensiero positivo o ringrazia per le piccole cose. Concediti un momento di tranquillità.",
                        image_description: "Una persona che guarda un tramonto, con colori caldi e un'atmosfera di pace.",
                        music_title: "Le Carnaval des Animaux: Le Cygne",
                        music_composer: "Camille Saint-Saëns",
                        image_data: null
                    }
                }
            };
            
            // Simula un tempo di caricamento per una migliore esperienza utente
            setTimeout(() => {
                navigateTo('dailyPlan', mockPlan);
            }, 1500);
            return;
        }

        // 1. Genera il piano testuale
        const prompt = await createGeminiPrompt(userAnswers);
        const textPayload = {
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        "profile": { "type": "STRING" },
                        "schedule": {
                            "type": "OBJECT",
                            "properties": {
                                "Mattino (8:00)": {
                                    "type": "OBJECT",
                                    "properties": {
                                        "message": { "type": "STRING" },
                                        "image_description": { "type": "STRING" },
                                        "music_title": { "type": "STRING" },
                                        "music_composer": { "type": "STRING" }
                                    }
                                },
                                "Metà giornata (11:00)": {
                                    "type": "OBJECT",
                                    "properties": {
                                        "message": { "type": "STRING" },
                                        "image_description": { "type": "STRING" },
                                        "music_title": { "type": "STRING" },
                                        "music_composer": { "type": "STRING" }
                                    }
                                },
                                "Pomeriggio (14:00)": {
                                    "type": "OBJECT",
                                    "properties": {
                                        "message": { "type": "STRING" },
                                        "image_description": { "type": "STRING" },
                                        "music_title": { "type": "STRING" },
                                        "music_composer": { "type": "STRING" }
                                    }
                                },
                                "Sera (18:00)": {
                                    "type": "OBJECT",
                                    "properties": {
                                        "message": { "type": "STRING" },
                                        "image_description": { "type": "STRING" },
                                        "music_title": { "type": "STRING" },
                                        "music_composer": { "type": "STRING" }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };

        let textResponse;
        for (let i = 0; i < 3; i++) {
            try {
                textResponse = await fetch(textApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(textPayload)
                });
                if (textResponse.status !== 429) break;
                await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
            } catch (error) {
                console.error('Errore durante la chiamata API (testo):', error);
                navigateTo('error', { message: 'Errore di connessione. Controlla la tua rete.' });
                return;
            }
        }
        if (!textResponse.ok) {
            console.error('API response failed:', textResponse.status);
            navigateTo('error', { message: 'Impossibile generare il piano. Riprova più tardi.' });
            return;
        }

        const textResult = await textResponse.json();
        const generatedText = textResult?.candidates?.[0]?.content?.parts?.[0]?.text;
        let plan;

        if (generatedText) {
            try {
                const cleanedText = generatedText.replace(/```json\n|```/g, '').trim();
                plan = JSON.parse(cleanedText);
            } catch (e) {
                console.error('Errore nel parsing JSON:', e);
                navigateTo('error', { message: 'Risposta non valida dall\'AI. Riprova.' });
                return;
            }
        } else {
            navigateTo('error', { message: 'Nessun piano generato. Riprova.' });
            return;
        }
        
        // 2. Genera immagini per ogni sezione
        const scheduleKeys = Object.keys(plan.schedule);
        for (const key of scheduleKeys) {
            const timeSlot = plan.schedule[key];

            // Generazione Immagine
            const imagePayload = { instances: [{ prompt: timeSlot.image_description }], parameters: { "sampleCount": 1 } };
            let imageResponse;
            for (let i = 0; i < 3; i++) {
                try {
                    imageResponse = await fetch(imageApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(imagePayload)
                    });
                    if (imageResponse.status !== 429) break;
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                } catch (error) {
                    console.error('Errore durante la chiamata API (immagine):', error);
                    continue;
                }
            }
            const imageResult = imageResponse?.ok ? await imageResponse.json() : null;
            plan.schedule[key].image_data = imageResult?.predictions?.[0]?.bytesBase64Encoded || null;
        }

        navigateTo('dailyPlan', plan);
    }
    
    /**
     * Crea un prompt per l'AI basato sulle risposte dell'utente e sui dati storici.
     */
    async function createGeminiPrompt(answers) {
        let mood = '';
        switch(answers.q1) {
            case 'energia': mood = 'pieno di energia e pronto a conquistare il mondo'; break;
            case 'assonnato': mood = 'che ha bisogno di una spinta per iniziare la giornata'; break;
            case 'calmo': mood = 'che cerca un messaggio di pace e tranquillità'; break;
            case 'incerto': mood = 'che ha bisogno di chiarezza e direzione'; break;
        }
        let copingMechanism = '';
        switch(answers.q2) {
            case 'solitudine': copingMechanism = 'che apprezza i momenti di solitudine'; break;
            case 'comunicazione': copingMechanism = 'che trova conforto nel comunicare con gli altri'; break;
            case 'musica': copingMechanism = 'che ama la musica come rifugio'; break;
            case 'natura': copingMechanism = 'che si sente a casa in mezzo alla natura'; break;
        }
        let inspiration = '';
        switch(answers.q3) {
            case 'sociale': inspiration = 'e che si sente motivato dalla connessione con gli altri'; break;
            case 'forza_interiore': inspiration = 'e che trae forza dal suo mondo interiore'; break;
            case 'opportunita': inspiration = 'e che ama esplorare nuove opportunità ogni giorno'; break;
        }

        const query = `Analizza le seguenti caratteristiche di una persona e crea un piano di benessere quotidiano.
Le risposte indicano un carattere ${mood}, un meccanismo di coping ${copingMechanism} e un'ispirazione ${inspiration}.
Il piano deve essere composto da un profilo dell'utente e da un programma con 4 messaggi, ciascuno con una descrizione dettagliata per un'immagine e un suggerimento di un brano di musica classica.
Il profilo deve essere una singola parola come "Il Sognatore", "L'Avventuriero", "L'Anima Solitaria" ecc.
Il programma deve includere 4 momenti:
1.  **Mattino (8:00):** Un messaggio per iniziare la giornata, una descrizione di un'immagine ispiratrice e il titolo e compositore di un brano di musica classica energico o edificante.
2.  **Metà giornata (11:00):** Un messaggio per superare la metà della mattinata, una descrizione di un'immagine di focus, e il titolo e compositore di un brano di musica classica che favorisca la concentrazione.
3.  **Pomeriggio (14:00):** Un messaggio per la ripartenza dopo pranzo, una descrizione di un'immagine di leggerezza, e il titolo e compositore di un brano di musica classica calmo o rilassante.
4.  **Sera (18:00):** Un messaggio per riflettere e concludere la giornata, una descrizione di un'immagine di tranquillità, e il titolo e compositore di un brano di musica classica per il relax o la riflessione.
Per ogni messaggio, includi un testo, una descrizione per l'immagine, il titolo del brano e il nome del compositore.
Il risultato finale deve essere un oggetto JSON con due chiavi: 'profile' e 'schedule'. 'schedule' deve contenere le 4 fasce orarie.
Assicurati che i titoli dei brani siano tra i seguenti: "Clair de Lune", "Gymnopédie No. 1", "Le Carnaval des Animaux: Le Cygne", "Nocturne in E-flat major, Op. 9, No. 2".
`;
        return query;
    }

    // Inizializza l'app dopo che tutto lo script è stato caricato.
    initApp();
</script>

</body>
</html>
